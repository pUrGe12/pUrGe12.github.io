+++
title = "Proof of concept for CVE-2025-21535"
date = 2025-01-27
draft = false

[taxonomies]
categories = ["Hacking", "Software", "CVE"]
tags = ["Hardware", "oracle", "Cysec"]

[extra]
lang = "en"
+++

Recently a professor in my college released a challenge,

> Create a poc for CVE-2025-21535 and win 5 grands

The offer sounds too good so naturally I am going to give it a try. What I am going to show here is execution of a command in a server that an unauthenticated user shoudn't have been able to. Read along to find out.

# What is the CVE about

In oracle's `WebLogic servers` version 12.2.1.4.0 and 14.1.1.0.0 lies a RCE (Remote Code Execution) vulnerability. This can be exploited by a specially crafted message sent via their proprietary `T3/IIOP protocol` to their admin servers.

Two major things to unpack here

1. What are WebLogic servers?
2. What is the T3/IIOP protocol?

`WebLogic` servers are simple servers that enable an admin to monitor a bunch of client machines. When setting it up, it asks for all the different clients the organisation has, whether to put them in a cluster or not and more. For our purposes, it is simply a server that enables special protocols like T3 to talk to it.

The thing here being that WebLogic servers are usually made to host `JAVA applications` and hence most of the code written will be JAVA and I have absolutely no idea about JAVA (say hello to AI).

The `T3` protocol was something developed under BEA Systems (which was later acquired by Oracle) to establish communications with a server. 

Lets understand T3 communications in details

## Client Initialization
The client (e.g., our Java application) initializes a connection to the WebLogic server using a T3 URL

### Connection Establishment

The client uses socket communication to connect to the WebLogic server over the specified port. T3 uses: 

- TCP/IP for reliable data transmission.
- Custom binary encoding (tag-length-value format) for efficient data transfer.

During this phase:

The client sends a handshake to establish compatibility and version negotiation. The server responds, confirming the connection.

### Session Creation

Once the connection is established, the server creates a persistent session for the client. This session is used to track stateful interactions between the client and the server.

### Request-Response Exchange
The client sends requests to the server, such as:

- **JNDI lookups**: Retrieving resources like DataSources, JMS connections, EJBs, etc
- **RMI invocations**: Invoking remote methods on server-side objects.
- **Deployment commands**: Deploying or managing applications.

The server processes the request and sends a response back to the client. The communication uses a tag-length-value format to efficiently encode data:

- **Tag**: Identifies the type of data or command.
- **Length**: Specifies the size of the data.
- **Value**: Contains the actual data or payload.

---

What about the `IIOP` protocol? I didn't really care for this one cause I figured T3 is probably the more important one. (I might be severely wrong so keeping this path open...)

## Setup procedure

1. **Installing pre-reqs**

The `first step` is establishing a vulnerable oracle WebLogic server to test our attacks out. The prerequesites for doing this can be installed using this

```sh
sudo apt update
```
Use this link: [oracle java archive](https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html) to download JAVA version 8, linux x64 tarred and gunzipped (unless if you're using windows, in which case good luck).

```sh
sudo mkdir -p /usr/lib/jvm 
sudo tar -xvzf ~/Downloads/jdk-8u202-linux-x64.tar.gz -C /usr/lib/jvm/
```

I have uses `202` cause that was the version I got, make sure you use your own. 

Check the java version, if it runs and shows the correct one, then you're good to go. Set it as default, 

```sh
export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_202
export PATH=$JAVA_HOME/bin:$PATH 
echo "export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_202" >> ~/.zshrc 
echo "export PATH=\$JAVA_HOME/bin:\$PATH" >> ~/.zshrc 
source ~/.zshrc
```

Use `bashrc` if you use bash and not `zsh`.

2. **Install WebLogic 12.2.1.4.0**

The second step is installing the WebLogic server. For this 

- Install an oracle account
- Download the version 12.2.1.4.0 generic version
- Unzip the file and install using JAVA

So, once you unzip you will see a `.jar` file. This is the installer for the server, and we will run this using 

```sh
java -jar fmw_12.2.1.4.0_wls_lite_generic.jar 
```

This will run a GUI, and it makes it much easier to setup. The few important things to keep in mind are:

- Template: simple webserver
- Advance feature: All of them
- Don't enable SSL (not really needed)
- No need for managed servers or clusters. Do not add `server templates` too. (this is different from the initial template we discussed)
- `Unix machine`: yes, add a unix machine. Not enabling GID or UID, listen address is localhost and node manager is 5556.
- Assigning the server to the node manager UNIX machine. Not setting up virtual targets.

After all this, you will be given a URL. That's where your server will go. However, we'll use `localhost` itself.

3. **Running the server**

Run the following commands to run the server locally.

```sh
cd /home/purge/Oracle/Middleware/Oracle_Home/user_projects/domains/vuln_domain
./startWebLogic.sh
```

I have used the name **vuln_domain**, yours may be different, so ensure you use the correct name. 

> Note that T3 protocol is enabled by default

## Testing the server 

The idea is to use T3 protocol to communicate with the WebLogic server and see if that works. Running the below code, it ensures that T3 is properly setup and it runs

```java
import weblogic.jndi.WLInitialContextFactory;

import javax.naming.Context;
import javax.naming.InitialContext;
import java.util.Hashtable;

public class WebLogicT3Client {
    public static void main(String[] args) {
        try {
            Hashtable<String, String> env = new Hashtable<>();
            env.put(Context.INITIAL_CONTEXT_FACTORY, "weblogic.jndi.WLInitialContextFactory");
            env.put(Context.PROVIDER_URL, "t3://localhost:7001");

            InitialContext ctx = new InitialContext(env);
            System.out.println("Connected to WebLogic via T3!");
            ctx.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

Save the above as `WebLogicT3Client.java`. Then run the below command to create the necessary `class`.

```sh
javac -cp /home/purge/Oracle/Middleware/Oracle_Home/wlserver/server/lib/weblogic.jar WebLogicT3Client.java
```

This should result in the creation of `WebLogicT3Client.class`. Then we execute the code using

```sh
java -cp .:/home/purge/Oracle/Middleware/Oracle_Home/wlserver/server/lib/weblogic.jar WebLogicT3Client
```

Also, change `purge` to whatever your username is. (Mine is purge cause purge means cool)

## The exploit

Alright now that the server is up and running, we need to find the exploit. According to the official documentation for the CVE in nvd.nist, we find that the `weakness enumeration` is `CWE-306`.

`CWE-306`: The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.

or it might mean this as well.

Exposing critical functionality essentially provides an attacker with the privilege level of that functionality. The consequences will depend on the associated functionality, but they can range from reading or modifying sensitive data, accessing administrative or other privileged functionality, or possibly even executing arbitrary code.

But what does this means for us? It can be either of the two things

1. Some functionality that only the admin should be doing, could be performed by an unauthenticated user as well
2. Something related to JAVA serialisation vulnerability

I don't want to look at JAVA serialisation objects yet without first checking the first option extensively. We know there are 3 major things that can be done by an admin in the WebLogic servers,

- **JNDI lookups**
- **RMI invocations**
- **Deployment commands**

So, I am gonna first test if I can retrieve or query these using non-admin privileges. If I can, well, thats bad.